allprojects {
    apply plugin: 'visual-studio'

    // Adds the Console SubSystem so Ctrl-F5 force you to press any key to close the
    // console window.
    model {
        visualStudio {
            projects.all {
                projectFile.withXml {
                    asNode().PropertyGroup.findAll({ it.@Label == 'NMakeConfiguration' }).each {
                        asNode().appendNode('ItemDefinitionGroup', [Condition: it.@Condition])
                            .appendNode('Link').appendNode('SubSystem', 'Console');
                    }
                }
            }
        }
    }

    plugins.withType(CppPlugin) {
        binaries.all {
            cppCompiler.args '/EHsc'
        }
        
        binaries.withType(NativeExecutableBinarySpec).matching({it.component.name.endsWith("Test")}).all {
            cppCompiler.define "GTEST_LANG_CXX11", "1"
            linker.args '/SUBSYSTEM:CONSOLE'
            lib project: ':externals:gmock', library: 'entryPoint', linkage: 'static'
            lib project: ':externals:gmock', library: 'core', linkage: 'static'
            lib project: ':externals:gtest', library: 'core', linkage: 'static'
        }
    }

    def addCompilerFlag = { NativeBinarySpec binary, String flag ->
        if (binary.hasProperty("cppCompiler")) {
            binary.cppCompiler.args flag
        }
        if (binary.hasProperty("cCompiler")) {
            binary.cCompiler.args flag
        }
    }
    
    def addCompilerDefine = { NativeBinarySpec binary, String define, String value ->
        if (binary.hasProperty("cppCompiler")) {
            binary.cppCompiler.define define, value
        }
        if (binary.hasProperty("cCompiler")) {
            binary.cCompiler.define define, value
        }
    }

    plugins.matching({it instanceof CppPlugin || it instanceof CPlugin}).all {
        binaries.all {
            addCompilerFlag it, "/W4"
            addCompilerFlag it, "/wd4206"  // translation unit is empty
            addCompilerDefine it, "WIN32", ""
            if (buildType.debug) {
                addCompilerFlag it, '/Zi'
                linker.args '/DEBUG'
            } else {
                linker.args '/RELEASE'
            }
        }
    }

    plugins.withType(NativeComponentModelPlugin) {
        model {
            buildTypes {
                debug {
                    ext.debug = true;
                }
                release {
                    ext.debug = false;
                }
            }
        }
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.3-20141212230053+0000'
}


apply plugin: 'c'
apply plugin: 'cpp'

model {
    repositories {
        libs(PrebuiltLibraries) {
            // Since we are not in total control of the command line and lib directive
            // are appended in order of declaration on the command line, we fake a library
            // for winsock so we can link the library after our test code which will make
            // our remaining winsock function linked with the normal implementation.
            winsock {
                binaries.withType(StaticLibraryBinary) {
                    staticLibraryFile = file('C:/Program Files (x86)/Windows Kits/8.1/Lib/winv6.3/um/x86/ws2_32.lib')
                }
            }
        }
    }

    components {
        main(NativeLibrarySpec)

        channel(NativeLibrarySpec)
        channelTest(NativeExecutableSpec) {
            sources {
                c {
                    source.srcDir "src/channel/c"
                }
            }
            binaries.all {
                lib library: 'channel', linkage: 'api'
                lib library: 'winsock', linkage: 'static'

                cCompiler.define "WINSOCK_API_LINKAGE", ""
                cppCompiler.define "WINSOCK_API_LINKAGE", ""
                cppCompiler.args '/GR'
                //linker.args 'Ws2_32.lib'
            }
        }

        thread(NativeLibrarySpec)
        threadTest(NativeExecutableSpec) {
            sources {
                c {
                    source.srcDir "src/thread/c"
                }
            }
            binaries.all {
                lib library: 'thread', linkage: 'api'

                cppCompiler.args '/GR'
            }
        }
    }
}

def buildAll = tasks.create("buildAll")
binaries.all {
    buildAll.dependsOn it
}

// Disable shared library for all component of this project
binaries.withType(SharedLibraryBinarySpec) {
    tasks.all {
        it.onlyIf {false}
    }
}

// All static library and test suite executable depends on the main component
binaries.matching({(it instanceof StaticLibraryBinarySpec || it instanceof NativeExecutableBinarySpec) && it.component.name != 'main'}).all {
    lib library: 'main', linkage: 'api'
}
